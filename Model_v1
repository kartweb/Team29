import pandas as pd
import numpy as np
import requests
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error
import warnings

# This is the function from the previous step.
# It's included here so the script is fully self-contained.
def create_modeling_dataframe():
    """Executes the full data engineering pipeline."""
    print("--- Starting Data Engineering Pipeline ---")
    try:
        dam_prices = pd.read_csv('C:/Users/diede/Downloads/dam_prices.csv')
        imbalance_actual = pd.read_csv('C:/Users/diede/Downloads/imbalance_actual.csv')
        imbalance_forecast = pd.read_csv('C:/Users/diede/Downloads/imbalance_forecast.csv')
    except FileNotFoundError as e:
        print(f"Error: A source file was not found. Please check paths.\n{e}")
        return None
    def prepare_and_resample(df):
        df['datetime_utc'] = pd.to_datetime(df['datetime_utc'])
        df.set_index('datetime_utc', inplace=True)
        return df.resample('15min').mean(numeric_only=True)
    df_actual = prepare_and_resample(imbalance_actual)
    df_dam = prepare_and_resample(dam_prices)
    df_forecast = prepare_and_resample(imbalance_forecast)
    master_df = pd.concat([df_actual['price_eur_mwh'].rename('actual_price'), df_dam['price_eur_mwh'].rename('dam_price'), df_forecast['price_eur_mwh'].rename('forecast_price')], axis=1)
    master_df.fillna(method='ffill', inplace=True)
    start_date, end_date = master_df.index.min().strftime('%Y-%m-%d'), master_df.index.max().strftime('%Y-%m-%d')
    params = {"latitude": 50.85, "longitude": 4.35, "start_date": start_date, "end_date": end_date, "hourly": "temperature_2m,shortwave_radiation,windspeed_10m"}
    response = requests.get("https://archive-api.open-meteo.com/v1/archive", params=params)
    if response.status_code == 200:
        data = response.json()['hourly']
        weather_df = pd.DataFrame(data)
        weather_df['time'] = pd.to_datetime(weather_df['time'])
        weather_df.set_index('time', inplace=True)
        master_df = master_df.join(weather_df.resample('15min').ffill(), how='left')
    master_df['hour'] = master_df.index.hour
    master_df['day_of_week'] = master_df.index.dayofweek
    master_df['is_weekend'] = (master_df['day_of_week'] >= 5).astype(int)
    master_df['month'] = master_df.index.month
    for lag in [1, 2, 4, 96]:
        master_df[f'actual_price_lag_{lag}'] = master_df['actual_price'].shift(lag)
    for window in [4, 96]:
        master_df[f'rolling_mean_{window}'] = master_df['actual_price'].shift(1).rolling(window=window).mean()
        master_df[f'rolling_std_{window}'] = master_df['actual_price'].shift(1).rolling(window=window).std()
    master_df.dropna(inplace=True)
    print("--- Data Engineering Pipeline Complete ---\n")
    return master_df

# --- Execute the Data Pipeline ---
master_df = create_modeling_dataframe()

if master_df is not None:
    # --- Step 1: Define Target and Features ---
    print("--- Step 1: Defining Target (y) and Features (X) ---")
    y = master_df['actual_price']
    X = master_df.drop(columns=['actual_price'])
    print(f"Target shape: {y.shape}")
    print(f"Features shape: {X.shape}")

    # --- Step 2: Create Chronological Train-Test Split ---
    print("\n--- Step 2: Splitting data into training and testing sets ---")
    test_size = 672  # Hold out the last 7 days for testing
    train_size = len(master_df) - test_size
    
    y_train, y_test = y.iloc[:train_size], y.iloc[train_size:]
    X_train, X_test = X.iloc[:train_size], X.iloc[train_size:]
    
    print(f"Training set size: {len(y_train)} periods")
    print(f"Testing set size:  {len(y_test)} periods")

    # --- Step 3: Train the SARIMAX Model ---
    print("\n--- Step 3: Training the SARIMAX model ---")
    print("This may take a few moments...")
    
    # With a rich feature set, a simpler (p,d,q) order is often effective and robust.
    # The features now carry most of the complex information.
    # We use (0,0,0,0) for seasonal order because our calendar features handle seasonality.
    model = SARIMAX(
        endog=y_train, 
        exog=X_train, 
        order=(2, 1, 1), # A reasonable starting point for (p,d,q)
        seasonal_order=(0, 0, 0, 0)
    )
    
    model_fit = model.fit(disp=False)
    print("Model training complete.")
    print(model_fit.summary())

    # --- Step 4: Make Predictions on the Test Set ---
    print("\n--- Step 4: Making predictions on the test set ---")
    predictions = model_fit.forecast(steps=len(y_test), exog=X_test)

    # --- Step 5: Performance Analysis ---
    print("\n--- Step 5: Analyzing model performance ---")

    # A. Quantitative Metrics
    mae = mean_absolute_error(y_test, predictions)
    rmse = np.sqrt(mean_squared_error(y_test, predictions))
    # Add a small epsilon to avoid division by zero in MAPE calculation
    mape = np.mean(np.abs((y_test - predictions) / (y_test.replace(0, 1e-6)))) * 100

    print("\n" + "="*40)
    print("       Model Performance Metrics")
    print("="*40)
    print(f"Mean Absolute Error (MAE):       {mae:.2f} EUR/MWh")
    print(f"Root Mean Squared Error (RMSE):  {rmse:.2f} EUR/MWh")
    print(f"Mean Absolute Percentage Error (MAPE): {mape:.2f}%")
    print("="*40 + "\n")

    # B. Visual Diagnostics
    plt.style.use('seaborn-v0_8-whitegrid')

    # Plot 1: Forecast vs. Actual Values
    plt.figure(figsize=(15, 7))
    plt.plot(y_test.index, y_test, label='Actual Prices', color='blue', lw=2)
    plt.plot(predictions.index, predictions, label='SARIMAX Predictions', color='red', linestyle='--', lw=2)
    plt.title('Forecast vs. Actual Prices on Test Set', fontsize=16)
    plt.xlabel('Time (UTC)')
    plt.ylabel('Price (â‚¬/MWh)')
    plt.legend()
    plt.show()

    # Plot 2: Residuals Analysis
    residuals = y_test - predictions
    
    fig, axes = plt.subplots(1, 2, figsize=(16, 6))
    
    # Residuals Over Time
    axes[0].plot(residuals.index, residuals)
    axes[0].axhline(0, linestyle='--', color='red')
    axes[0].set_title('Residuals Over Time', fontsize=14)
    axes[0].set_xlabel('Time (UTC)')
    axes[0].set_ylabel('Error')

    # Residuals Distribution
    sns.histplot(residuals, kde=True, ax=axes[1])
    axes[1].set_title('Distribution of Residuals', fontsize=14)
    axes[1].set_xlabel('Error Value')
    
    plt.suptitle('Model Residual Diagnostics', fontsize=18)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()
    
